"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1234],{7879:function(e,t,n){n.r(t),n.d(t,{default:function(){return h}});var l=n(8453),r=n(6540);function a(e){const t=Object.assign({p:"p",h5:"h5",img:"img",a:"a",strong:"strong"},(0,l.RP)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"一个编辑器经常会打开多个文件，同时查看多个文件也是家常便饭，多窗口也是编辑器的标配，这种情况下，窗口的有效管理也成为了一门功课。"),"\n",r.createElement(t.h5,null,"创建空窗口 👇"),"\n",r.createElement(t.p,null,"这应该是最基本的操作了，还可以分为水平和垂直创建"),"\n",r.createElement(t.img,{src:"/images/create-empty-pane.gif",alt:"Create Empty Pane"}),"\n",r.createElement(t.h5,null,"克隆窗口 👇"),"\n",r.createElement(t.p,null,"将当前窗口克隆一份，然后水平或者垂直地创建在新的窗口，这个操作在阅读源码时使用频率很高。"),"\n",r.createElement(t.img,{src:"/images/clone-pane.gif",alt:"Clone Pane"}),"\n",r.createElement(t.h5,null,"移动窗口 👇"),"\n",r.createElement(t.p,null,"将当前窗口进行水平或者垂直地移动至邻近窗口"),"\n",r.createElement(t.img,{src:"/images/move-pane.gif",alt:"Move Pane"}),"\n",r.createElement(t.h5,null,"调整窗口大小 👇"),"\n",r.createElement(t.p,null,"指的是存在多个窗口时，对当前窗口大小进行调整。如果显示器尺寸不大，或者窗口显示的内容过长或过短的情况下，这是一个很常用的操作，当然了，可以直接用鼠标搞定，快捷键自然会高效很多，像 Sublime Text 下的 ",r.createElement(t.a,{href:"https://github.com/SublimeText/Origami"},"Origami")," 插件甚至可以调整窗口的比例。我最常用的快捷键是 ",r.createElement(t.strong,null,"11"),", ",r.createElement(t.strong,null,"22"),", ",r.createElement(t.strong,null,"33"),", ",r.createElement(t.strong,null,"44"),", ",r.createElement(t.strong,null,"55"),"，分别代表将当前窗口比例大小设置为",r.createElement(t.strong,null,"10%"),"，",r.createElement(t.strong,null,"25%"),"，",r.createElement(t.strong,null,"50%"),"，",r.createElement(t.strong,null,"75%"),"，",r.createElement(t.strong,null,"90%"),"，具体的配置在",r.createElement(t.a,{href:"https://github.com/lattespirit/sublime-settings/blob/master/Default.sublime-keymap#L201-L235"},"这里"),"。 VS Code 里扩大和缩小窗口对应的指令分别是 ",r.createElement(t.strong,null,"workbench.action.increaseViewSize")," 和 ",r.createElement(t.strong,null,"workbench.action.decreaseViewSize"),"，有兴趣的可以自行配置。"),"\n",r.createElement(t.img,{src:"/images/resize-pane.gif",alt:"Resize Pane"}),"\n",r.createElement(t.h5,null,"窗口搜索跳转 👇"),"\n",r.createElement(t.p,null,"设想一下，当前编辑器打开了很多文件，这些文件甚至分布在多窗口中，此时想从当前正在编辑的文件跳转至其他窗口中未显示的文件，这时候即得用到鼠标点击目标文件的标签才能达到目的了。这种情况好比在一个浏览器中，打开了十几个标签，从一个标签直接跳到另一个标签。"),"\n",r.createElement(t.p,null,"期望的效果是这样，",r.createElement(t.strong,null,"用户可以根据当前打开文件的文件名进行过滤，选择并跳转至该文件"),"，这样的操作显然是高效的，但目前我还没发现有哪个编辑器默认支持这一效果(如果有，请留言评论，不胜感激)，最类似的一个实现是 JetBrains 家的 IDE 下，可以打开一个面板，显示最近打开的文件，并能输入文件名跳转至该文件。还有，使用这个",r.createElement(t.a,{href:"https://github.com/lattespirit/sublime-tab-jumper"},"插件"),"，Sublime Text 下能完美实现期望的效果"),"\n",r.createElement(t.img,{src:"/images/tab-jumper.gif",alt:"Tab Jumper"}),"\n",r.createElement(t.h5,null,"侧边栏显示文件树结构 👇"),"\n",r.createElement(t.p,null,"对于当前打开的文件，可以",r.createElement(t.strong,null,"选择性"),"地在侧边栏显示文件的目录树结构，",r.createElement(t.strong,null,"选择性"),"的目的在于，有些编辑器的侧边栏默认是实时展示当前文件的目录树结构的，即每编辑一个文件，侧边栏则对应地显示树结构，这对于一部分人来说有些烦人，期望的效果是想它展示的时候触发即可。"),"\n",r.createElement(t.img,{src:"/images/reveal-in-sidebar.gif",alt:"Reveal in sidebar"}),"\n",r.createElement(t.p,null,"下一篇将会聊到",r.createElement(t.strong,null,"文件管理"),"。"))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.RP)(),e.components);return t?r.createElement(t,e,r.createElement(a,e)):a(e)},s=n(4794),c=n(8199),i=n(7418),o=n(6662),u=n(6063),g=n(6543),p=n(2415);const E=e=>{let{data:t,pageContext:n,children:a}=e;const m=t.mdx,{prev:E,next:h}=n,d=E?"上篇":"未始",f=h?"下篇":"未央",x=E?E.fields.slug:m.fields.slug,b=h?h.fields.slug:m.fields.slug,w="flex items-center w-24 h-8 text-sm mr-18 lg:mr-32 bg-gray-lighter hover:bg-purple-light text-purple-dark hover:text-white opacity-85 rounded-full no-underline cursor-"+(E?"pointer":"not-allowed"),k="flex justify-end items-center w-24 h-8 text-sm bg-gray-lighter hover:bg-purple-light text-purple-dark hover:text-white opacity-85 rounded-full no-underline cursor-"+(h?"pointer":"not-allowed");return r.createElement(i.A,null,r.createElement(c.A,{title:m.frontmatter.title}),r.createElement("div",{className:"flex flex-col items-center box mt-4 px-4 md:px-8 lg:px-12 py-2 md:py-4 rounded-lg",style:{backgroundColor:"rgba(237, 242, 247, 0.85)"}},r.createElement("p",{className:"text-lg x:text-xl md:text-2xl font-bold mt-4"},m.frontmatter.title),r.createElement("p",{className:"text-sm x:text-base text-gray-darkest my-2"},m.fields.date),r.createElement("div",{className:"text-sm md:text-base paragraph"},r.createElement(l.xA,{components:{...u.A,Carousel:g.A,Car:p.A}},a))),r.createElement("div",{className:"flex justify-between x:justify-center h-6 box mt-8"},r.createElement(s.Link,{className:w,to:`/${x}`},r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round",className:"feather feather-chevrons-left w-4 h-4 stroke-current inline-block mx-3"},r.createElement("polyline",{points:"11 17 6 12 11 7"}),r.createElement("polyline",{points:"18 17 13 12 18 7"})),r.createElement("p",null,d)),r.createElement(s.Link,{className:k,to:`/${b}`},r.createElement("p",null,f),r.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round",className:"feather feather-chevrons-right w-4 h-4 stroke-current inline-block mx-3"},r.createElement("polyline",{points:"13 17 18 12 13 7"}),r.createElement("polyline",{points:"6 17 11 12 6 7"})))),r.createElement(o.A,{disqus:{slug:m.fields.slug,title:m.frontmatter.title}}))};function h(e){return r.createElement(E,e,r.createElement(m,e))}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-posts-2020-05-24-editor-essential-3-pane-md-4e95c33655e2ffee0046.js.map